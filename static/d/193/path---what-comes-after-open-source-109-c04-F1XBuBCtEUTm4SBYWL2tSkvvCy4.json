{"data":{"site":{"siteMetadata":{"title":"Denis Nazarov","author":"Denis Nazarov"}},"markdownRemark":{"id":"195cd06f-b066-56e0-be4d-0cb83f579b24","excerpt":"Combinatorial innovation is an invention algorithm by which existing ideas are combined in novel ways to create new ideas. The output is fed back into the…","html":"<p><img src=\"/maze2-ddba308f41f1cdffc93fbfd27ced935d.gif\"></p>\n<p>Combinatorial innovation is an invention algorithm by which existing ideas are combined in novel ways to create new ideas. The output is fed back into the process to generate more new ideas, ad infinitum. </p>\n<p>As more ideas explored, more possibilities present themselves.</p>\n<p>There are some prerequisites for combinatorial innovation to happen effectively.</p>\n<p><strong>Connectivity</strong>: Technologies like language, writing, and printing have interconnected humans at unprecedented scale. Life in cities, collaboration at universities and firms and other innovative social structures and institutions have contributed to connectivity.</p>\n<p><strong>Unrestricted flow of ideas</strong>: The enlightenment and the spread of the scientific method created a culture of sharing and peer review, most recently embodied in the open source software movement.</p>\n<p><strong>Incentives</strong>: Capitalism fuels a a global marketplace for ideas.</p>\n<p>Complex ideas are composed of smaller independent building blocks, leading to <strong>modularity</strong>.</p>\n<p>Participants specialize to divide and conquer improving the modules comprising a technology, creating fractal competition and innovation at every layer. </p>\n<h2>Innovation in software</h2>\n<p>Software is the ultimate environment for combinatorial innovation. It excels, by orders of magnitude, in each of these dimensions.</p>\n<p>The internet is the ultimate connectivity network in terms of speed, cost, and convenience. Open source software culture, predicated on frictionless sharing and reuse of building blocks of code, dominates the software development practice. Billions of users with interconnected devices present an unprecedented addressable market.</p>\n<p>The universality of the turing machine is the ultimate substrate for modularity. Any piece of code can run on any computer, and can be universally recomposed.</p>\n<p>Software is like a new physics, without the innefficiencies and friction of building in the real world.</p>\n<h2>Software tools</h2>\n<p>The nature of pre-internet software is similar to products of the industrial era. I will refer to them as tools—products that are useful in and of themselves.</p>\n<p>In the physical world, I buy a car for the personal utility of getting myself from point A to point B. </p>\n<p>Early software focused on creating superior digital versions of information tools concieved of in the industrial era.</p>\n<table>\n<thead>\n<tr>\n<th>Software tool</th>\n<th>Industrial tool</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Word processor (WordPerfect)</td>\n<td>Typewriter</td>\n</tr>\n<tr>\n<td>Spreadsheet (Excel)</td>\n<td>Accounting book</td>\n</tr>\n<tr>\n<td>Graphics editor (Photoshop)</td>\n<td>Darkroom</td>\n</tr>\n</tbody>\n</table>\n<p>Tool-like software has certain key properties.</p>\n<p>It is <strong>self contained</strong>. All that is necessary is to run the code and it’ll do something useful. There are no external dependencies. Word processor software, for example, is so independently useful that <a href=\"https://en.wikipedia.org/wiki/Wang_Laboratories\">successful companies</a> were built selling  computers with that single purpose.</p>\n<p>It provides <strong>single player utility</strong>. Just like when pounding in nails with a hammer, you don’t need anything or anyone else to use the tool.</p>\n<p>Instances are <strong>interchangable</strong>. If you forget your laptop, you could borrow mine to retouch your pictures in my instance of Photoshop. </p>\n<p>Not suprisingly, the initial business model for tool-like software was selling licenses. Piracy naturally emerged because the tools were so useful, but also easy and inexpensive to copy.</p>\n<p>The open source community rapidly created openly-licensed alternatives to most properietry software—free to use and modify. Other software, especially in the broad category that powers cloud infrastructure, like databases, began its life as open source from the beginning.</p>\n<h2>Code vs state</h2>\n<p>To understand how the nature of software evolves, it is important to to distinguish between the <strong>logic</strong> (code) of a program and its capacity to <strong>remember</strong> (state).</p>\n<p>Early programs were functional in nature—an input led to an output. A story in your mind is translated to a digital document with the aid of a word processor. A scanned photo is cropped and text is overlaid with image processing software.</p>\n<p>The ability to remember preceding events or user interactions (state) was primitive and minimal. State also only came from the single user of the program.</p>\n<h2>Internet services</h2>\n<p>Personal computing is defined by the idea of each user running a personal instance of a program on their computer. The internet is defined by a new class of software centered around the idea of a server.</p>\n<p>Instead of a “one computer, one program”, where there are many identical instances of software, a server operator (or company) runs only one instance of a program on their server. Lots of people connect to it and interact with it over the internet. This is called a service.</p>\n<p><em>Instead of a user maintaining their own state, a service maintains state on a user’s behalf.</em> </p>\n<p>This simple notion had unprecedented consequences that enabled building some of the most powerful and impactful products in history. </p>\n<p>Let’s look at the generic definition of “service”:</p>\n<blockquote>\n<p>a system supplying a public need such as transport, communications, or utilities such as electricity and water.</p>\n</blockquote>\n<p>Services are categorically different than tools.</p>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Service</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Car</td>\n<td>Transportation network</td>\n</tr>\n<tr>\n<td>Engine</td>\n<td>Power grid</td>\n</tr>\n<tr>\n<td>Personal blog</td>\n<td>Social network</td>\n</tr>\n<tr>\n<td>RSS reader</td>\n<td>Search engine</td>\n</tr>\n<tr>\n<td>Shopify</td>\n<td>Amazon</td>\n</tr>\n<tr>\n<td>TensorFlow</td>\n<td>Google Ads</td>\n</tr>\n<tr>\n<td>Unity</td>\n<td>Dota 2</td>\n</tr>\n<tr>\n<td>Amazon S3</td>\n<td>Instagram</td>\n</tr>\n</tbody>\n</table>\n<p>Services thrive from scale. They desire to be global and singular. They have long lifespans and they operate autonomously. One is usually certain to get more value from plugging into an existing service than from building their own.</p>\n<p>Services can be deployed in data centers to enable applications that require scale that would be infeasable for a personal computer. For example, a crawler of the entire web. </p>\n<p>Services are long-running and improve over time as they aggregate more state. A user may interact with the service to address a personal need. For example, to find a certain website. A byproduct of satisfying the need is updating the global state, for example, to update the ranking of a website in the system, affecting results for all users. Even though users are using the service for personal needs, the service gets smarter and more useful for all users.</p>\n<p>Crucially, the utility of the <strong>code</strong> of a service begins to diverge with the utility of its <strong>state</strong> over its lifespan.</p>\n<p>State compounds and becomes more valuable superlinearly. Code, while crucial for stable operation and evolution, in turn becomes less important and necessary to defend. It is not surprising that most services are primary composed of open source software.</p>\n<p>Anyone can attempt to clonse a service or even run the same code, but the service with a lot more of users will have a lot more useful state, and will thereby be more desirable to users. This creates a feedback loop, where more users beget more state, leading to a more useful service that attracts even more users.</p>\n<h2>Back to code</h2>\n<p>The software that defines the internet era is composed of tool-like software (databases, etc), but results in <strong>services</strong>. </p>\n<p>The code of a service, when instantiated, creates a vessel for persisting state that starts off empty. It becomes useful only when it is filled with users, data, or both. </p>\n<p>Services depend on a healthy network and require a critical mass. They are more efficient when they singular in nature—fracturing state among multiples services makes each less useful than if they were one (monopolies are a natural and stable state).</p>\n<h2>Innovation in software services</h2>\n<p>State is a critical component that is <strong>omitted</strong> from the combinatorial innovation framework for open source. A service’s incentives are built around monetizing their state. State is the competitive advantage and it needs to be defended by keeping it <strong>proprietary and closed</strong>. There is therefore <strong>no connectivity</strong> between innovators and the flow of ideas is <strong>restricted</strong>.</p>\n<p>As my parnter Chris <a href=\"https://www.wired.com/story/how-blockchain-can-wrest-the-internet-from-corporations/\">has written</a>, this is why we are seeing a great consolidation in internet services and a lack of innovation.</p>\n<p>As Chris described, DNS is one successful open service that fits into the combinatorial innovation model and has remained open, resulting in a bunch of downsteram innovation.</p>\n<p>Crypto networks are likely to provide the correct incentives to create <strong>open services</strong> in all kinds of areas.</p>\n<p>I will discuss open services in more detail in a future post.</p>","frontmatter":{"title":"What comes after open source?","date":"January 11, 2019"}}},"pageContext":{"slug":"/what-comes-after-open-source/","previous":{"fields":{"slug":"/reading-piles-of-books/"},"frontmatter":{"title":"Reading piles of books"}},"next":null}}